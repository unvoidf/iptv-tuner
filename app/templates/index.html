<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üì° IPTV Tuner - Safe-Stream</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #1a1a1a;
            color: #e0e0e0;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        .card {
            background-color: #242424;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .input-field {
            background-color: #2a2a2a;
            border: 1px solid #404040;
            color: #e0e0e0;
        }

        .input-field:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .btn-primary {
            background-color: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background-color: #2563eb;
        }

        .btn-secondary {
            background-color: #374151;
            color: white;
        }

        .btn-secondary:hover {
            background-color: #4b5563;
        }

        .category-item {
            background-color: #2a2a2a;
            border: 1px solid #404040;
            padding: 8px 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-ok {
            background-color: #10b981;
        }

        .status-warning {
            background-color: #f59e0b;
        }

        .status-error {
            background-color: #ef4444;
        }
    </style>
</head>

<body>
    <div id="app" class="min-h-screen p-6">
        <div class="max-w-4xl mx-auto">
            <!-- Header -->
            <div class="mb-8 text-center">
                <h1 class="text-3xl font-bold mb-2">üì° IPTV Tuner</h1>
                <p class="text-gray-400">Safe-Stream with Kill-Switch Protection</p>
            </div>

            <!-- Settings Card -->
            <div class="card p-6 mb-6">
                <h2 class="text-xl font-semibold mb-4">‚öôÔ∏è Settings</h2>

                <!-- M3U URL -->
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">M3U Playlist URL</label>
                    <input v-model="settings.m3u_url" type="text" class="input-field w-full px-3 py-2 rounded"
                        placeholder="http://example.com/playlist.m3u" />
                </div>

                <!-- User-Agent -->
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">User-Agent</label>
                    <input v-model="settings.user_agent" type="text" class="input-field w-full px-3 py-2 rounded"
                        placeholder="VLC/3.0.18 LibVLC/3.0.18" />
                </div>

                <!-- Kill-Switch Delay -->
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">
                        Kill-Switch Delay: <span class="text-blue-400">{{ settings.kill_switch_delay_ms
                            }}ms</span>
                    </label>
                    <input v-model.number="settings.kill_switch_delay_ms" type="range" min="200" max="3000" step="100"
                        class="w-full" />
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>200ms (Fast)</span>
                        <span>3000ms (Safe)</span>
                    </div>
                </div>

                <!-- Read Timeout -->
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">
                        Stream Read Timeout: <span class="text-blue-400">{{ settings.read_timeout_seconds }}s</span>
                    </label>
                    <input v-model.number="settings.read_timeout_seconds" type="range" min="10" max="60" step="5"
                        class="w-full" />
                    <div class="flex justify-between text-xs text-gray-500 mt-1">
                        <span>10s</span>
                        <span>60s</span>
                    </div>
                </div>

                <!-- Update Interval -->
                <div class="mb-4">
                    <label class="block text-sm font-medium mb-2">Auto-Update Interval</label>
                    <select v-model.number="settings.update_interval_hours"
                        class="input-field w-full px-3 py-2 rounded">
                        <option :value="6">Every 6 Hours</option>
                        <option :value="12">Every 12 Hours</option>
                        <option :value="24">Every 24 Hours</option>
                        <option :value="48">Every 48 Hours</option>
                    </select>
                </div>

                <!-- Action Buttons -->
                <div class="flex gap-3">
                    <button @click="saveSettings" class="btn-primary px-4 py-2 rounded font-medium" :disabled="loading">
                        {{ loading ? '‚è≥ Saving...' : 'üíæ Save' }}
                    </button>
                    <button @click="refreshM3U" class="btn-secondary px-4 py-2 rounded font-medium" :disabled="loading">
                        ‚ö° Update Now
                    </button>
                </div>

                <!-- Status Message -->
                <div v-if="statusMessage" class="mt-4 p-3 rounded" :class="statusClass">
                    {{ statusMessage }}
                </div>
            </div>

            <!-- Category Filters Card -->
            <div class="card p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl font-semibold">üìã Channel Categories</h2>
                    <button @click="toggleAllCategories" class="text-sm text-blue-400 hover:text-blue-300">
                        {{ allSelected ? 'Deselect All' : 'Select All' }}
                    </button>
                </div>

                <div v-if="categories.length === 0" class="text-gray-500 text-center py-4">
                    Categories will appear here after M3U is loaded
                </div>

                <div v-else class="grid grid-cols-1 md:grid-cols-2 gap-3">
                    <label v-for="category in categories" :key="category.name"
                        class="category-item cursor-pointer hover:bg-gray-700 transition-colors">
                        <input type="checkbox" :value="category.name" v-model="settings.selected_categories"
                            class="w-4 h-4" />
                        <span>{{ category.display }}</span>
                    </label>
                </div>
            </div>

            <!-- Status Footer -->
            <div class="card p-4">
                <div class="flex justify-between items-center flex-wrap gap-4">
                    <div>
                        <span class="status-indicator" :class="statusIndicator"></span>
                        <span class="ml-2 text-sm">{{ connectionStatus }}</span>
                    </div>
                    <div class="text-sm text-gray-400">
                        Active Channels: <span class="text-white font-semibold">{{ channelCount }}</span>
                    </div>
                    <div class="text-sm text-gray-400">
                        Last Update: <span class="text-white">{{ lastUpdate }}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        createApp({
            data() {
                return {
                    settings: {
                        m3u_url: '',
                        user_agent: 'VLC/3.0.18 LibVLC/3.0.18',
                        selected_categories: [],
                        update_interval_hours: 12,
                        kill_switch_delay_ms: 1000,
                        read_timeout_seconds: 30
                    },
                    categories: [],
                    loading: false,
                    statusMessage: '',
                    statusType: 'success',
                    lastUpdate: 'Not loaded yet',
                    channelCount: 0
                };
            },
            computed: {
                allSelected() {
                    return this.categories.length > 0 &&
                        this.settings.selected_categories.length === this.categories.length;
                },
                categoryNames() {
                    return this.categories.map(c => c.name);
                },
                statusClass() {
                    return this.statusType === 'success'
                        ? 'bg-green-900 text-green-200 border border-green-700'
                        : 'bg-red-900 text-red-200 border border-red-700';
                },
                statusIndicator() {
                    if (this.settings.m3u_url && this.channelCount > 0) return 'status-ok';
                    if (this.settings.m3u_url) return 'status-warning';
                    return 'status-error';
                },
                connectionStatus() {
                    if (this.settings.m3u_url && this.channelCount > 0) return 'Connected';
                    if (this.settings.m3u_url) return 'M3U Configured';
                    return 'Not Configured';
                }
            },
            methods: {
                async loadSettings() {
                    try {
                        const response = await fetch('/api/settings');
                        const data = await response.json();
                        this.settings = { ...this.settings, ...data };
                    } catch (error) {
                        console.error('Error loading settings:', error);
                    }
                },
                async loadCategories() {
                    try {
                        const response = await fetch('/api/categories');
                        this.categories = await response.json();
                    } catch (error) {
                        console.error('Error loading categories:', error);
                    }
                },
                async loadHealth() {
                    try {
                        const response = await fetch('/health');
                        const data = await response.json();
                        this.channelCount = data.channels_loaded || 0;
                        if (this.channelCount > 0) {
                            this.lastUpdate = new Date().toLocaleString();
                        }
                    } catch (error) {
                        console.error('Error loading health:', error);
                    }
                },
                async saveSettings() {
                    this.loading = true;
                    this.statusMessage = '';

                    try {
                        const response = await fetch('/api/settings', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(this.settings)
                        });

                        if (response.ok) {
                            this.statusMessage = '‚úÖ Settings saved successfully!';
                            this.statusType = 'success';
                            await this.loadCategories();
                            await this.loadHealth();
                        } else {
                            throw new Error('Save failed');
                        }
                    } catch (error) {
                        this.statusMessage = '‚ùå Failed to save settings!';
                        this.statusType = 'error';
                        console.error('Error saving settings:', error);
                    } finally {
                        this.loading = false;
                        setTimeout(() => { this.statusMessage = ''; }, 5000);
                    }
                },
                async refreshM3U() {
                    this.loading = true;
                    this.statusMessage = '';

                    try {
                        const response = await fetch('/api/refresh', { method: 'POST' });

                        if (response.ok) {
                            this.statusMessage = '‚úÖ M3U updated successfully!';
                            this.statusType = 'success';
                            await this.loadCategories();
                            await this.loadHealth();
                        } else {
                            throw new Error('Refresh failed');
                        }
                    } catch (error) {
                        this.statusMessage = '‚ùå Failed to update M3U!';
                        this.statusType = 'error';
                        console.error('Error refreshing M3U:', error);
                    } finally {
                        this.loading = false;
                        setTimeout(() => { this.statusMessage = ''; }, 5000);
                    }
                },
                toggleAllCategories() {
                    if (this.allSelected) {
                        this.settings.selected_categories = [];
                    } else {
                        this.settings.selected_categories = this.categoryNames;
                    }
                }
            },
            async mounted() {
                await this.loadSettings();
                await this.loadCategories();
                await this.loadHealth();

                // Auto-refresh health every 30 seconds
                setInterval(() => {
                    this.loadHealth();
                }, 30000);
            }
        }).mount('#app');
    </script>
</body>

</html>